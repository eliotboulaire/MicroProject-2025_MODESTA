<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Eliot Boulaire">
<meta name="dcterms.date" content="2024-12-09">

<title>Micro-project 2025 : MODESTA</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Instructions_files/libs/clipboard/clipboard.min.js"></script>
<script src="Instructions_files/libs/quarto-html/quarto.js"></script>
<script src="Instructions_files/libs/quarto-html/popper.min.js"></script>
<script src="Instructions_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Instructions_files/libs/quarto-html/anchor.min.js"></script>
<link href="Instructions_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Instructions_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Instructions_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Instructions_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Instructions_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#size-structured-demographic-models-on-marine-phase-of-atlantic-salmon" id="toc-size-structured-demographic-models-on-marine-phase-of-atlantic-salmon" class="nav-link active" data-scroll-target="#size-structured-demographic-models-on-marine-phase-of-atlantic-salmon">Size-structured demographic models on marine phase of Atlantic salmon</a>
  <ul class="collapse">
  <li><a href="#context" id="toc-context" class="nav-link" data-scroll-target="#context">Context</a>
  <ul class="collapse">
  <li><a href="#environnemental-context" id="toc-environnemental-context" class="nav-link" data-scroll-target="#environnemental-context">Environnemental context</a></li>
  <li><a href="#main-hypothesis" id="toc-main-hypothesis" class="nav-link" data-scroll-target="#main-hypothesis">Main hypothesis</a></li>
  <li><a href="#modelisation-context" id="toc-modelisation-context" class="nav-link" data-scroll-target="#modelisation-context">Modelisation context</a></li>
  <li><a href="#micro-project-framework" id="toc-micro-project-framework" class="nav-link" data-scroll-target="#micro-project-framework">Micro-project framework</a></li>
  </ul></li>
  <li><a href="#objectives" id="toc-objectives" class="nav-link" data-scroll-target="#objectives">Objectives</a></li>
  <li><a href="#resources" id="toc-resources" class="nav-link" data-scroll-target="#resources">Resources</a>
  <ul class="collapse">
  <li><a href="#study-site" id="toc-study-site" class="nav-link" data-scroll-target="#study-site">Study site</a></li>
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data">Data</a></li>
  <li><a href="#model" id="toc-model" class="nav-link" data-scroll-target="#model">Model</a></li>
  </ul></li>
  <li><a href="#guidelines" id="toc-guidelines" class="nav-link" data-scroll-target="#guidelines">Guidelines</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="Instructions.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Micro-project 2025 : MODESTA</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Eliot Boulaire </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 9, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="size-structured-demographic-models-on-marine-phase-of-atlantic-salmon" class="level1">
<h1>Size-structured demographic models on marine phase of Atlantic salmon</h1>
<p>Spé/M2 SHA - Option REA<br>
2023 - 2024<br>
UE MODH - UC : “Quantitative analysis for resources and fisheries modelisation”</p>
<section id="context" class="level2">
<h2 class="anchored" data-anchor-id="context">Context</h2>
<section id="environnemental-context" class="level3">
<h3 class="anchored" data-anchor-id="environnemental-context">Environnemental context</h3>
<p>Aquatic ecosystems are increasingly impacted by anthropogenic pressures, such as overexploitation, habitat degradation, and climate change. These disturbances significantly affect ecosystem functioning and the sustainability of natural resources (Worm et al., 2006; IPBES, 2019).</p>
<p>Diadromous fish, such as the Atlantic salmon (Salmo salar), are especially vulnerable due to their reliance on both marine and continental ecosystems. Classified as ‘Near Threatened’ by the IUCN, salmon have faced threats in recent decades linked to changes in the marine ecosystem (recently updated from ‘Least Concern’ to ‘Near Threatened’ in 2023). Salmon populations have experienced substantial declines, particularly due to reduced survival rates of young salmon during the marine phase (Chaput, 2012; ICES, 2017). This decline is accompanied by shifts in life-history traits, such as accelerated maturation (Jonsson et al., 2016; Olmos et al., 2019) and reduced adult size (Todd et al., 2012; Bal et al., 2017; Vollset et al., 2022), leading to lower fecundity (Hanson et al., 2020) and a loss of intra-population diversity, which weakens the ‘portfolio effect’ (Carlson and Satterthwaite, 2011; Schindler et al., 2010). These changes ultimately compromise population resilience, making them more sensitive to environmental pressures and exploitation.</p>
<p><strong>In this context, gaining a deeper understanding of the mechanisms that drive salmon populations’ responses to global change is crucial. This knowledge will improve our ability to assess their current state and inform the development of effective management strategies.</strong></p>
</section>
<section id="main-hypothesis" class="level3">
<h3 class="anchored" data-anchor-id="main-hypothesis">Main hypothesis</h3>
<p>The rapid changes observed in the structure and functioning of salmon populations suggest a response to alterations in the ecosystem, particularly a decline in the quantity and quality of trophic resources available during the marine phase of the life cycle (ICES, 2017).</p>
<p>Available data indicates that growth plays a crucial role in the main demographic transitions throughout the salmon life cycle, influenced by trade-offs specific to each sex.</p>
<ul>
<li><p>Growth is a key integrative trait of global change (including climate change) that reflects an individual’s ability to acquire resources from its environment, assimilate them, and allocate them to various functions.</p></li>
<li><p>Growth is also a life-history trait (LHT) influenced by trade-offs with other major LHTs, such as individual mortality (Friedland et al., 2009) or size and age at maturation (Mobley et al., 2021), among others.</p></li>
</ul>
<p>Specifically, the size of individuals during the smolt migration to the sea increases the probability of survival and successful return (i.e., “bigger is better”: Gregory et al., 2019; Simmons et al., 2021). Additionally, the decision to sexually mature, which determines the return for reproduction, is partly influenced by reaching a size threshold at the end of the first summer at sea, with larger individuals having a greater likelihood of triggering maturation (Mobley et al., 2021; Tréhin et al., 2023). This threshold is typically higher for females, who, on average, have a lower probability of maturing after just one winter at sea compared to males of similar size.</p>
<p><strong>Given the importance of growth in demographic processes, any change in growth due to environmental variations will have significant impacts on population structure and, ultimately, population dynamics.</strong></p>
</section>
<section id="modelisation-context" class="level3">
<h3 class="anchored" data-anchor-id="modelisation-context">Modelisation context</h3>
<p>However, current population models used for fish stock assessments struggle to explicitly account for the variability of phenotypic traits (such as size) between individuals and/or over time. By neglecting variations in size, these models generate biased estimates of population dynamics, limiting the relevance and accuracy of their projections. In contrast, individual-based models have investigated the influence of growth on the life histories of Atlantic salmon, but their complexity makes them challenging to apply for quantitative assessments based on field data.</p>
<p><strong>To address this issue, the development of population models structured by life stages and size is essential for improving our understanding of observed variations and enhancing our ability to predict population responses under multiple pressures. The Integral Projection Models (IPMs) approach is proposed as a promising alternative. Positioned between individual-based models and age-structured models in terms of complexity, IPMs offer a more effective framework for incorporating the impacts of growth on population dynamics.</strong></p>
</section>
<section id="micro-project-framework" class="level3">
<h3 class="anchored" data-anchor-id="micro-project-framework">Micro-project framework</h3>
<p>This micro-project is part of a broader framework of a PhD research aiming to analyze the influence of individual growth variations on the population dynamics of Atlantic salmon. The goal is to improve the tools used to assess their status and propose more robust management measures adapted to environmental pressures. The first step of this project involves characterizing key demographic transitions (survival and maturation) during the marine phase of Atlantic salmon in relation to individual size.</p>
<p>A major challenge lies in drawing conclusions about the hidden processes of survival and maturation that occur between the smolt stage, during their migration to the sea, and the adult stage, when they return to rivers after their marine phase. To address this challenge, indirect information on individual growth during these hidden stages is obtained through the analysis of archival tissues, such as scales, which allow the reconstruction of individual life histories.</p>
<p><strong>A model structured by age, stage, sex, and size has been developed to accommodate the complex life cycle of Atlantic salmon</strong>. It was built within an integrated hierarchical statistical modeling framework. This approach is well-suited for combining diverse sources of observations to infer hidden demographic processes (Schaub &amp; Abadi, 2011; Zipkin et al., 2019).</p>
</section>
</section>
<section id="objectives" class="level2">
<h2 class="anchored" data-anchor-id="objectives">Objectives</h2>
<p><u>Current modeling has limitations :</u></p>
<p>While it accounts for annual data and sex proportions, it does not incorporate these factors into the formalization of size-dependent survival and maturation transitions. <strong>The first objective</strong> is to improve the modeling of survival and maturation processes by integrating annual variations and sex differences, based on existing literature.</p>
<p>The current model uses indirect size information from scales, assuming an isometric relationship between scale size and body size. However, this assumption appears inconsistent with findings in the literature. <strong>The second objective</strong> is to introduce three back-calculation models for estimating salmon body size from scale size, chosen based on literature, and assess the variability introduced by their application.</p>
<p>Due to the current reliance on scale size modeling, no direct links with population state indicators used in management could be established. <strong>The final objective</strong> is to leverage the three back-calculation models to develop a direct connection to egg deposition (a proxy for fecundity and population renewal), which will provide valuable insights for management decisions.</p>
</section>
<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<section id="study-site" class="level3">
<h3 class="anchored" data-anchor-id="study-site">Study site</h3>
<p>This work is based on long-term monitoring data (24 years of smolt cohorts from 1996 to 2019) of natural salmon populations collected by the <em>Observatoire de Recherche en Environnement petits Fleuves Côtiers</em> (ORE DiaPFC) and the <em>Centre National pour l’Interprétation des Captures de Salmonidés</em> (CNICS). These data are centralized in information systems managed by INRAE.</p>
<p>Specifically, the data pertain to the Scorff salmon population, a river in the Morbihan region of Brittany. The Scorff drains a 483 km² basin over a 77 km course, joining the Blavet at a common estuary near Lorient. A migration monitoring station has been operational since 1994 at the <em>Moulin des Princes</em> (MdP) site in Pont-Scorff. This station enables the trapping of smolts during downstream migration and adults during upstream migration. Each captured salmon is measured, weighed, and has scales sampled before being released. The collected scales are archived in the ichthyological collection COLISA (<em>Marchand et al., 2021</em>), managed by INRAE and OFB.</p>
</section>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">Data</h3>
<p>The data, which has not yet been published, will be shared with you via USB during the first session. Please ensure that the data is deleted after the completion of the course.</p>
<section id="abundance-estimations" class="level4">
<h4 class="anchored" data-anchor-id="abundance-estimations">Abundance estimations</h4>
<p>The counting data collected at the MdP station are imperfect, as some salmon can bypass the trap, particularly during periods of heavy rainfall. To address this, mark-recapture experiments are conducted to estimate:</p>
<ul>
<li><p><strong>Trap efficiency</strong> based on flow conditions,</p></li>
<li><p><strong>The abundance of migrating smolts</strong> (across all age classes),</p></li>
<li><p><strong>Adult returns</strong>, categorized into two age classes: 1SW (one-sea-winter) and 2SW (two-sea-winter).</p></li>
</ul>
<p>These estimates, derived from 24 years of data, are produced using Bayesian hierarchical models that account for imperfect detection (<em>Buoro et al., 2019</em>).</p>
</section>
<section id="molecular-sexing" class="level4">
<h4 class="anchored" data-anchor-id="molecular-sexing">Molecular sexing</h4>
<p>Sexual dimorphism in salmon at the time of trapping (both at the smolt and adult stages) is not pronounced enough to allow reliable sex identification.</p>
<p>To address this, a sample of 30 scales from 30 different individuals per smolt cohort year and life stage was selected to determine sex using DNA extracted from scale tissues (<em>i.e.</em>, molecular sexing: Besnard et al., 2023). However, reliable sex identification was only possible for a subset of the sample, as DNA extracted from older scales was often too degraded. Additionally, since sexing was not performed after 2018, limited information is available for the most recent cohorts.</p>
<p>In total, the sex of only … individuals could be identified, with significant temporal variation (see figure).</p>
</section>
<section id="scale-size" class="level4">
<h4 class="anchored" data-anchor-id="scale-size">Scale size</h4>
<p>The model uses individual data from scale readings to estimate the size structure of the population. A sample of 30 scales from 30 different individuals per smolt cohort year and life stage was selected to determine the growth ring sizes at various audit stages (see figure). Scales are calcified structures that grow alongside the individual, are easy to collect, and have minimal impact on the fish’s life.</p>
<p>The scales are collected from a “standard zone” (see figure) on the fish’s body, where scales first develop during the fry stage. The scale size from this area is the most strongly correlated with the salmon’s body size (Baglinière et al., 1985; Shearer, 1992).</p>
</section>
</section>
<section id="model" class="level3">
<h3 class="anchored" data-anchor-id="model">Model</h3>
<p>Le modèle est formulé dans le cadre d’un modèle de population intégré à espace d’état (modèle hiérarchique) bayésien qui permet d’intégrer différentes sources de données (l’abondance, le rapport des sexes et la structure de taille) et les erreurs d’observation associées, afin d’estimer la dynamique de population représentée par des stades et des transitions démographiques latentes, non-directement observables (Figure 2). Ce modèle est composé de 3 stades observées (smolts, 1HM et 2HM) et 4 stades latents (smolts survivants, post-smolts à la maturation, post-smolts maturant et post-smolts non-maturant) (Figure 1 et 2). Ce modèle est également sexé, les abondances dans chaque stade sont représentées séparément pour les mâles et les femelles (indice s). La structure en taille est représentée à chaque stade par k = 52 classes (indice l). Ce niveau de discrétisation offre un bon compromis entre la modélisation des transitions taille-dépendantes sous la forme de taux de transition (taux de survie, taux de maturation) dépendant explicitement de la classe de taille et l’efficacité computationnelle. Le modèle est également structuré en fonction du temps, représenté par l’année de dévalaison des smolts, soit 24 cohortes (indices t). L’abondance et les transitions sont représentées indépendamment pour chaque cohorte. A noter cependant que la croissance entre les stades n’est pas représentée dans ce modèle.&nbsp;</p>
<p>Pour chaque cohorte t, le premier stade représenté est le stade de smolt migrant (au printemps de l’année t) (Figure 2). Les smolts passent alors un premier été en mer jusqu’à la fin de l’été de l’année t (novembre) durant lequel ils sont soumis à une première transition démographique de survie jusqu’au stade de smolt survivants (Figure 2). Après le premier été en mer, les smolts survivants intègrent tous le stade post-smolts à la maturation, c’est-à-dire des smolts qui réalisent la transition démographique avec une décision de maturation ou non. Ces post-smolts ont des structures de taille différentes du stade précédent, cependant l’étape de croissance entre les smolts survivants et les post-smolts à la maturation n’est pas modélisée. Les post-smolts maturants retourneront dans leur rivière natale comme adultes au stade de retour après 1HM (juillet de l’année t+1), conditionnellement à une survie post-maturation fixe. Les post-smolts non-maturants retourneront au stade adulte de retour après 2HM (mai de l’année t+2) (Figure 2), conditionnellement à une survie post-maturation fixe. Afin de limiter la confusion dans l’estimation statistique des deux taux de transition précédents, la survie post-maturation est considérée connue et ne varie ni en fonction de la taille, ni en fonction du sexe, ni en fonction de la cohorte. Conditionnellement aux taux de transitions précédents, les transitions sont modélisées comme déterministes. Les taux de survie et de maturation sont appliqués de façon multiplicative sur les abondances pour les différents stades (observé ou latent), sexes (s), classes de taille (l) et cohorte (t). Ces deux transitions sont potentiellement dépendantes de la classe de taille, potentiellement différentes entre les mâles et les femelles et différentes entre les cohortes de smolts. L’étape de croissance entre les post-smolts maturants ou non-maturants et les adultes de retour en 1HM ou 2HM n’est pas modélisée.</p>
</section>
</section>
<section id="guidelines" class="level2">
<h2 class="anchored" data-anchor-id="guidelines">Guidelines</h2>
<ol type="1">
<li><p>qzd</p></li>
<li><p>qzd</p></li>
<li><p>dqz</p></li>
</ol>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>